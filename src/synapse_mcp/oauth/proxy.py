"""FastMCP OAuth proxy extensions for Synapse."""

import logging
import os
from typing import Any, List, Optional
from urllib.parse import parse_qsl, urlencode, urlparse, urlunparse

from fastmcp.server.auth import OAuthProxy
from fastmcp.server.auth.oauth_proxy import ProxyDCRClient
from pydantic import AnyUrl, TypeAdapter

from ..session_storage import create_session_storage
from .client_registry import (
    ClientRegistration,
    create_client_registry,
    load_static_registrations,
)

logger = logging.getLogger("synapse_mcp.oauth")


class SessionAwareOAuthProxy(OAuthProxy):
    """OAuth proxy that mirrors tokens into session storage."""

    def __init__(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)
        self._session_storage = create_session_storage()
        # Note: MCP session tracking removed - OAuth is purely token-based
        # MCP sessions are optional, auto-generated by FastMCP for protocol features
        # Authentication uses Bearer tokens with user identity from JWT sub claim
        self._client_registry = create_client_registry(os.environ)
        if not hasattr(self, "_clients"):
            # Guard against older fastmcp versions where OAuthProxy skipped initialization.
            self._clients = {}
        self._restore_registered_clients()
        logger.debug(
            "SessionAwareOAuthProxy initialized with session storage %s and client registry %s",
            type(self._session_storage).__name__,
            type(self._client_registry).__name__,
        )

    async def load_access_token(self, token: str):
        """Override to add debugging for load_access_token flow."""
        logger.info("=== SessionAwareOAuthProxy.load_access_token ===")
        logger.info("Loading token: %s***", token[:20] if token else "None")
        result = await super().load_access_token(token)
        logger.info("load_access_token result: %s", "found" if result else "None")
        return result

    async def verify_token(self, token: str):
        """Override to add debugging for token verification flow."""
        logger.info("=== SessionAwareOAuthProxy.verify_token ===")
        logger.info("Incoming token: %s***", token[:20] if token else "None")

        # Check if token is in internal cache
        access_tokens = getattr(self, "_access_tokens", {})
        logger.info("Tokens in _access_tokens cache: %d", len(access_tokens))
        for i, cached_token in enumerate(access_tokens.keys()):
            logger.debug("  Cached token %d: %s***", i, cached_token[:20])

        if token in access_tokens:
            logger.info("Token FOUND in _access_tokens cache")
            cached = access_tokens[token]
            logger.debug(
                "Cached token info: client_id=%s, scopes=%s, expires_at=%s",
                getattr(cached, "client_id", None),
                getattr(cached, "scopes", None),
                getattr(cached, "expires_at", None),
            )
            return cached

        logger.info(
            "Token NOT in cache - calling token_verifier.verify_token()")
        result = await super().verify_token(token)
        logger.info("Verifier returned: %s",
                    "valid token" if result else "None (INVALID)")
        return result

    def _restore_registered_clients(self) -> None:
        try:
            registrations = list(self._client_registry.load_all())
        except Exception as exc:  # pragma: no cover - defensive
            logger.warning("Failed to load persisted OAuth clients: %s", exc)
            return

        # Merge statically configured clients (highest priority)
        try:
            registrations.extend(load_static_registrations())
        except Exception as exc:  # pragma: no cover - defensive
            logger.warning("Failed to load static OAuth clients: %s", exc)

        default_grants = ["authorization_code", "refresh_token"]

        for record in registrations:
            if record.client_id in self._clients:
                continue
            try:
                adapter = TypeAdapter(List[AnyUrl])
                redirect_source = record.redirect_uris if record.redirect_uris else [
                    "http://127.0.0.1"]
                redirect_uris = adapter.validate_python(redirect_source)
                proxy_client = ProxyDCRClient(
                    client_id=record.client_id,
                    client_secret=record.client_secret,
                    redirect_uris=redirect_uris,
                    grant_types=record.grant_types or default_grants,
                    scope=self._default_scope_str,
                    token_endpoint_auth_method="none",
                    allowed_redirect_uri_patterns=self._allowed_client_redirect_uris,
                )
                self._clients[record.client_id] = proxy_client
                logger.info("Restored registered OAuth client %s",
                            record.client_id)
                logger.debug("Client details: id=%s, redirect_uris=%s, grants=%s",
                             record.client_id, redirect_uris, record.grant_types or default_grants)
            except Exception as exc:  # pragma: no cover - defensive
                logger.warning(
                    "Failed to restore OAuth client %s: %s", record.client_id, exc)

    async def register_client(self, client_info):
        logger.debug("register_client called with: id=%s, redirect_uris=%s, grants=%s",
                     client_info.client_id, client_info.redirect_uris, client_info.grant_types)
        await super().register_client(client_info)

        try:
            registration = ClientRegistration(
                client_id=client_info.client_id,
                client_secret=_extract_secret(client_info.client_secret),
                redirect_uris=[str(uri)
                               for uri in (client_info.redirect_uris or [])],
                grant_types=list(client_info.grant_types or [
                                 "authorization_code", "refresh_token"]),
            )
            self._client_registry.save(registration)
            logger.debug("Persisted OAuth client %s with redirect_uris=%s and grants=%s",
                         client_info.client_id, registration.redirect_uris, registration.grant_types)
        except Exception as exc:  # pragma: no cover - defensive
            logger.warning("Unable to persist OAuth client %s: %s",
                           client_info.client_id, exc)

    async def _handle_idp_callback(self, request, *args, **kwargs):
        logger.info("=== OAUTH CALLBACK ===")
        logger.debug("Processing OAuth callback from identity provider")

        existing_tokens = set(getattr(self, "_access_tokens", {}).keys())
        logger.debug("Existing tokens: %s", [t[:8] + "***" for t in existing_tokens])

        result = await super()._handle_idp_callback(request, *args, **kwargs)

        # Clean up empty state parameters in redirect
        if result and hasattr(result, "headers"):
            location = result.headers.get("location")
            if location:
                parsed = urlparse(location)
                query_pairs = parse_qsl(parsed.query, keep_blank_values=True)
                filtered_pairs = [
                    (key, value)
                    for key, value in query_pairs
                    if not (
                        key == "state"
                        and (
                            value is None
                            or value == ""
                            or (isinstance(value, str) and value.lower() == "none")
                        )
                    )
                ]

                if len(filtered_pairs) != len(query_pairs):
                    new_query = urlencode(filtered_pairs, doseq=True)
                    new_location = urlunparse(parsed._replace(query=new_query))
                    result.headers["location"] = new_location
                    logger.debug("Removed empty state parameter from callback redirect")

        # Map new tokens to users via JWT subject claim
        if result:
            try:
                await self._map_new_tokens_to_users()
                logger.info("✓ Callback complete - tokens mapped to users via JWT")
            except Exception as exc:  # pragma: no cover - defensive
                logger.warning("Failed to map tokens to users: %s", exc)
        else:
            logger.debug("No result returned from super()._handle_idp_callback")

        return result

    async def exchange_authorization_code(
        self,
        client: Any,
        authorization_code: Any,
    ):
        logger.info("=== OAUTH CODE EXCHANGE ===")
        logger.debug("Exchanging authorization code for access token (client_id=%s)",
                     getattr(client, 'client_id', None))

        existing_tokens = set(getattr(self, "_access_tokens", {}).keys())
        token_response = await super().exchange_authorization_code(client, authorization_code)

        # Map new tokens to users via JWT subject claim
        try:
            await self._map_new_tokens_to_users()
        except Exception as exc:  # pragma: no cover - defensive
            logger.warning("Failed to map tokens to users after exchange: %s", exc)

        access_tokens = getattr(self, "_access_tokens", {})
        new_tokens = [token for token in access_tokens if token not in existing_tokens]
        logger.debug("New tokens from exchange: %s", [t[:8] + "***" for t in new_tokens])

        # Log token response for client
        logger.info("=== TOKEN EXCHANGE COMPLETE ===")
        if hasattr(token_response, "access_token"):
            at = token_response.access_token
            logger.info("✓ Access token issued: %s***", at[:30] if at else None)
            logger.info("Client MUST include this token as: Authorization: Bearer <token>")
            logger.info("Client MUST send this header in ALL subsequent /mcp requests")
        if hasattr(token_response, "token_type"):
            logger.info("Token type: %s", token_response.token_type)
        if hasattr(token_response, "expires_in"):
            logger.info("Token expires in: %s seconds", token_response.expires_in)

        return token_response

    async def _map_new_tokens_to_users(self) -> None:
        existing_users = await self._session_storage.get_all_user_subjects()
        access_tokens = getattr(self, "_access_tokens", {})
        known_attrs = [attr for attr in dir(
            self) if "token" in attr.lower() and not attr.startswith("__")]
        logger.debug(
            "_map_new_tokens_to_users: existing_users=%s tokens=%s token_attrs=%s",
            existing_users,
            [t[:8] + "***" for t in access_tokens],
            {attr: _summarize_token_attr(attr, getattr(
                self, attr, None)) for attr in known_attrs},
        )
        unmapped_tokens = [token for token in access_tokens if await self._session_storage.find_user_by_token(token) is None]
        logger.debug("Unmapped tokens: %s", [
                     t[:8] + "***" for t in unmapped_tokens])

        for token_key in unmapped_tokens:
            try:
                import jwt

                decoded = jwt.decode(token_key, options={
                                     "verify_signature": False})
                user_subject = decoded.get("sub")
                logger.debug("Decoded token %s***: subject=%s",
                             token_key[:8], user_subject)
                if user_subject:
                    await self._session_storage.set_user_token(user_subject, token_key, ttl_seconds=3600)
                    logger.info("Mapped token %s*** to user %s",
                                token_key[:20], user_subject)
                else:
                    logger.warning(
                        "Token %s*** has no subject claim", token_key[:20])
            except Exception as exc:  # pragma: no cover - decoding failures
                logger.warning("Failed to decode token %s***: %s",
                               token_key[:20], exc)

    async def get_user_token(self, user_subject: str) -> Optional[str]:
        token_key = await self._session_storage.get_user_token(user_subject)
        if token_key and token_key in self._access_tokens:
            return token_key
        return None

    async def cleanup_user_tokens(self, user_subject: str) -> None:
        token_key = await self._session_storage.get_user_token(user_subject)
        if token_key:
            if token_key in self._access_tokens:
                del self._access_tokens[token_key]
            await self._session_storage.remove_user_token(user_subject)
            logger.info("Cleaned up token for user %s", user_subject)

    async def cleanup_expired_tokens(self) -> None:
        await self._session_storage.cleanup_expired_tokens()

        existing_users = await self._session_storage.get_all_user_subjects()
        mapped_tokens = {
            token
            for user_subject in existing_users
            for token in [await self._session_storage.get_user_token(user_subject)]
            if token
        }

        orphaned = [token for token in list(
            self._access_tokens.keys()) if token not in mapped_tokens]
        for token in orphaned:
            if self._is_token_old_enough_to_cleanup(token):
                del self._access_tokens[token]

        if orphaned:
            logger.info("Cleaned up %s orphaned tokens from OAuth proxy", len(orphaned))

    def _is_token_old_enough_to_cleanup(self, token: str, min_age_seconds: int = 30) -> bool:
        try:
            import jwt
            from datetime import datetime, timezone

            decoded = jwt.decode(token, options={"verify_signature": False})
            issued_at = decoded.get("iat")
            if not issued_at:
                return True
            token_age = datetime.now(timezone.utc).timestamp() - issued_at
            if token_age <= min_age_seconds:
                logger.debug(
                    "Token is only %.1fs old, keeping for now", token_age)
                return False
            return True
        except Exception as exc:  # pragma: no cover - decoding failures
            logger.debug(
                "Error checking token age, assuming old enough: %s", exc)
            return True

    async def iter_user_tokens(self) -> list[tuple[str, str]]:
        """Return all known (subject, token) pairs from storage."""

        tokens: list[tuple[str, str]] = []
        subjects = await self._session_storage.get_all_user_subjects()
        for subject in subjects:
            token = await self._session_storage.get_user_token(subject)
            if token:
                tokens.append((subject, token))
        logger.debug("iter_user_tokens -> %s",
                     [(sub, tok[:8] + "***") for sub, tok in tokens])
        return tokens

    async def get_token_for_current_user(self) -> Optional[tuple[str, Optional[str]]]:
        """Return a token/subject pair when a single active user is known."""

        tokens = await self.iter_user_tokens()
        if len(tokens) == 1:
            subject, token = tokens[0]
            return token, subject
        return None

    # Note: Session-based token lookup methods removed
    # OAuth authentication is purely token-based via Authorization header
    # Use get_user_token() or get_token_for_current_user() instead


def _extract_session_id(request) -> Optional[str]:
    try:
        logger.debug("_extract_session_id: checking request headers and state")
        if hasattr(request, "headers"):
            session_id = request.headers.get("mcp-session-id")
            logger.debug("  mcp-session-id header: %s", session_id)
            if session_id:
                return session_id
        if hasattr(request, "state"):
            session_context = getattr(request.state, "session_context", None)
            logger.debug("  session_context: %s", session_context)
            if session_context and hasattr(session_context, "session_id"):
                logger.debug("  session_context.session_id: %s",
                             session_context.session_id)
                return session_context.session_id
        logger.warning(
            "No session_id found in request (checked headers and state)")
    except Exception as exc:  # pragma: no cover - defensive
        logger.debug("Could not extract session ID from callback: %s", exc)
    return None


def _extract_secret(secret: Any) -> Optional[str]:
    if secret is None:
        return None
    try:
        return secret.get_secret_value()  # type: ignore[attr-defined]
    except AttributeError:
        return secret  # type: ignore[return-value]


def _mask_token(token: Optional[str]) -> Optional[str]:
    if not token:
        return token
    return token[:8] + "***"


def _summarize_token_attr(attr: str, value: Any) -> Any:
    if value is None:
        return None

    if attr == "_access_tokens" and isinstance(value, dict):
        summary: dict[str, dict[str, Any]] = {}
        for token, data in value.items():
            masked = _mask_token(token) or "<missing>"
            summary[masked] = {
                "client_id": getattr(data, "client_id", None),
                "scopes": getattr(data, "scopes", None),
                "expires_at": getattr(data, "expires_at", None),
            }
        return summary

    if attr == "_refresh_tokens" and isinstance(value, dict):
        summary = {}
        for token, data in value.items():
            masked = _mask_token(token) or "<missing>"
            summary[masked] = {
                "client_id": getattr(data, "client_id", None),
                "scopes": getattr(data, "scopes", None),
            }
        return summary

    if isinstance(value, dict):
        return {"type": "dict", "count": len(value)}

    if isinstance(value, (list, set, tuple)):
        return {"type": type(value).__name__, "count": len(value)}

    return type(value).__name__


__all__ = ["SessionAwareOAuthProxy"]
